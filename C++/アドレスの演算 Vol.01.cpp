//アドレスで計算するにはどんな意味があるのか

//配列のある要素のアドレス&n[i]と&n[j]の引き算をすることでi-jが得られる。

//・・・・・・・・・・・・・・・・・処理・・・・・・・・・・・・・・・・・//
//#include <iostream>
//using namespace std;
//
//int main()
//{
//	int n[5];
//
//	cout << "n[2]     = " << (size_t)&n[2]       << endl;
//	cout << "n[2] + 1 = " << (size_t)(&n[2] + 1) << endl;
//	cout << "n[3]     = " << (size_t)&n[3]       << endl;
//}
//・・・・・・・・・・・・・・・・・処理・・・・・・・・・・・・・・・・・//

//実行結果
//n[2]     = 16514556
//n[2] + 1 = 16514560
//n[3]     = 16514560

//配列のある要素のアドレス &n[i]に値jを足すと、その数だけ先の配列に進む
//&n[i + j]になるということがわかる。
//引き算の場合も同じで&n[i - j]になる。


//ポインタを用いた方法
//・・・・・・・・・・・・・・・・・処理・・・・・・・・・・・・・・・・・//
//#include <iostream>
//using namespace std;
//
//int main()
//{
//	int n[4];
//	int* p = n;
//
//	cout << "p     = " << (size_t)p     << endl;
//	cout << "&n[0] = " << (size_t)&n[0] << endl;
//
//	p += 2;
//	cout << "p     = " << (size_t)p     << endl;
//	cout << "&n[2] = " << (size_t)&n[2] << endl;
//}
//・・・・・・・・・・・・・・・・・処理・・・・・・・・・・・・・・・・・//

//実行結果
//p     = 8714176
//&n[0] = 8714176

//pに2を足した結果
//p     = 8714184
//&n[2] = 8714184

//まずint型のポインタであるpをn[0]の値を入れて初期化している。
//そしてそのpに2を足してあげるとn[0]だった中身はn[2]になっていることがわかる。
//このようにアドレスの足算や引き算などは可能であることがわかる。
//掛け算や割り算はよほどのことがあったとしてもやる必要性はない。
//そのため、乗余算はできないようになっている。
//どうしてもやりたい場合はint型にキャストするとできる。